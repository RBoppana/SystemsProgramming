Design:

Our first design issue was to decide how to properly store the data from the CSV file. We initially decided to create a specific struct for the provided data columns from IMDB. In addition, since we wouldn't know how many rows were present in the CSV and would only get a single chance to parse through the data, we decided to store the data in a linked list and copy it over to an array at a later time.

After some consideration with this design we realized that we would encounter trouble with dynamically accessing the desired value from the struct, as well as being unable to complete the extra credit. To address this we changed our design to instead store each row as an array of unions, each of which contains either an integer, a double, or a pointer to a string. 

This design also seemed complicated to implement during the mergesort stage so we revised it and finalized with an array of structs called "Listings" containing only 2 fields: the first being a string of the a given row in the CSV, and the second also a string but of the Column-Of-Interest in that row. (The column value that we would be sorting on.) 

Reading in these values required the use of a few helper functions to properly initialize the strings and checking commas and quotes when traverse the CSV. Since we would need to store strings of unknown length, we decided to implement a function to read characters from a file pointer and reallocate the string to a larger char array whenever necessary.

To find the Column-Of-Interest, we counted the "nthComma" until we reached a the column in the header row(first row of the CSV) that matched the input parameter; we used string tokenizer to traverse the header row.

*Since we did not know the number of rows in the CSV, we stored them in a LinkedList and then transferred them over to an array.

Once everything was read in properly and the Listing array called "data" was populated correctly, we also initizalized "indexArray" which would simply store the array indexes of the "data" array 0 to n-1, n being the number of rows. For simplicity's sake, and to preserve the original data for testing purposes, the mergesort algorithm only sorts the values in the index array and at the end, the "data" array is printed out in the order presented in "indexArray". 

